# **CRUD REST API**

В одной из прошлых работ мы пользовались сторонним API, теперь сами создадим простоe REST API для работы с базой данных с использованием ORM и засунем его в Docker-контейнер. 

> ORM: https://ru.wikipedia.org/wiki/ORM
> 
> CRUD: https://ru.wikipedia.org/wiki/CRUD
> 
> REST API: https://blog.skillfactory.ru/glossary/rest-api/
> 
Напишем сервис для реальной библиотеки, который позволяет получать информацию о книгах, читателях и сдавать книги читателям.


Воспользуемся веб-фреймворком FastAPI:

> Инструкция по установке, запуску и много чему еще есть в документации - https://fastapi.tiangolo.com/

## Теория API

После установки fastapi напишем простое приложение и протестируем его.

Структура небольшого сервиса обычно выглядит так:

```
/rest_api_app
    - /modules - дополнительный функционал, который не должен быть в app.py
        - utils.py - утилиты для работы со временем
    - app.py - файл с API 
```

В `app.py` напишем простое приложение:

```python
from fastapi import FastAPI

app = FastAPI()

@app.get('/')
def get_homepage() -> dict[str, str]:
    return {'message': 'Hello World!'}

```

Запустим приложение:

```sh
$ uvicorn app:app
```

После этого можно перейти на http://localhost:8000/docs и увидеть там Swagger, там же можно потыкать апи и посмотреть, что происходит с приложением

## Простая версия

Для начала накидаем MVP нашего сервиса

Там должны быть такие эндпоинты (минимальный функционал, остальное на ваше усмотрение):

1) `GET /books` - получение всех книг
2) `POST /books` - добавление новой книги в базу
3) `GET /books/{id}` - получение информации о конкретной книге
4) `POST /books/{id}` - обновление информации о книге 
5) `GET /clients` - получение списка клиентов (читателей)
6) `POST /clients` - регистрация нового читателя
7) `GET /clients/{id}` - получение информации о клиенте (читателе)
8) `GET /books/cross` - получение списки книг, сданных читателям (со сроками возврата)
9) `POST /books/cross` - изменить статус книги (например, сдана читателю или возвращена в библиотеку)


Само собой, необходимы проверки на `адекватность` пользователя для предотвращения таких смешных ситуаций:

1) Сдача книги, которая уже сдана другому читателю
2) Сдача книги несуществующему читателю
3) Создание пользователя или книги, которые уже существуют в базе

и аналогичных.

В простой версии информацию о книгах можно хранить в простом словаре, например так:

```python
books: dict[int, dict[str, str]] = {
    1: {'title': '1984', 'author': 'Orwell'},
    2: {'title': 'Crime and Punishment', 'author': 'Dostoevsky'}
}
```

Соответственно, с `books` можно будет проводить операции:

```python
book = books[1]
print(book) 
# {'title': '1984', 'author': 'Orwell'} - получение данных о книге по ее номеру

books[3] = {'title': 'Captains Daughter', 'author': 'Pushkin'}
# добавление книги или редактирование данных о существующей в базе
```

Аналогично можно поступить как с данными о читателях, так и с данными о сданных в чтение книгах

Постепенно вы заметите, что словарь с данными о книгах связан со словарем с данными о статусе книг, а словарь со статусом книг связан со словарем с данными о читателях. А еще вы заметите, что при перезапуске приложения новые данные куда-то пропадают. Пора заменить словари на SQL таблицы!

## Сложная версия (итоговая)

Воспользуйтесь ORM `SQLAlchemy` для создания таблиц и работы с ними. Замените все словари и логику работы с ними на ORM модели. Документации по работе с этой ОРМ полно в интернете, расписывать смысла нет.

Для начала хватит и `sqlite3`, самые отважные могут привязать `postgresql` и запускать сервер Postgres в докере, рядом с нашим сервисом. Кстати о докере...

### Docker

Как я упомянул, будем использовать Docker для упрощения развертывания. Необходимо создать и описать Dockerfile, помимо него еще и docker-compose.yml (с ним проще).

> Информация и примеры использования:
> https://fastapi.tiangolo.com/deployment/docker/


## Итоговый результат:

Рабочий сервис для администрирования библиотеки. Круто!

